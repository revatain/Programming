-- 전체 데이터 확인
SELECT *
FROM EMPLOYEES e;

-- 조건 확인
SELECT *
FROM EMPLOYEES e
WHERE EMPLOYEE_ID < 110;

-- 데이터 정렬
SELECT *
FROM EMPLOYEES e
WHERE EMPLOYEE_ID < 110
ORDER BY FIRST_NAME DESC;

-- 데이터 그룹화
SELECT DEPARTMENT_ID, SUM(SALARY) 
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

-- 데이터 그룹화 + 조건
SELECT DEPARTMENT_ID, SUM(SALARY) 
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING SUM(SALARY) > 100000;

-- 중복데이터 제거
SELECT DISTINCT JOB_ID FROM EMPLOYEES e;

-- 파일 출력
-- 직원 이름 / 월급
SELECT FIRST_NAME AS "직원 이름", SALARY AS 월급 FROM EMPLOYEES e;

-- 숫자 표현
-- dual은 테스트용 가상 테이블이다.
SELECT 1 FROM dual;

-- 문자 표현
SELECT '안녕하세요' FROM dual;

-- 비교 연산자
SELECT * FROM EMPLOYEES e WHERE FIRST_NAME = 'Steven';

-- 연결 연산자
SELECT EMPLOYEE_ID, FIRST_NAME  || LAST_NAME FROM EMPLOYEES e

-- @test.com
SELECT EMAIL || '@test.com'
FROM EMPLOYEES e;

-- SELECT문 계산
-- 10% 보너스
SELECT FIRST_NAME, SALARY, SALARY * 0.1 FROM EMPLOYEES e;

-- where 조건
-- = <= != BETWEEN, IN, LIKE, IS NULL

-- 110 ~ 115번 직원을 출력하세요.
SELECT * FROM EMPLOYEES e
WHERE EMPLOYEE_ID >= 110 AND EMPLOYEE_ID <= 115;

SELECT * FROM EMPLOYEES e
WHERE EMPLOYEE_ID BETWEEN 110 AND 115;

SELECT * FROM EMPLOYEES e
WHERE EMPLOYEE_ID >= 110 OR EMPLOYEE_ID >= 115 OR EMPLOYEE_ID >= 117;

SELECT * FROM EMPLOYEES e
WHERE EMPLOYEE_ID IN (110, 115, 117);

-- LIKE는 문자열 비교시 많이 이용.
SELECT * FROM EMPLOYEES e WHERE FIRST_NAME LIKE 'Steven';

-- 문자열 일부 검색 (%)
SELECT * FROM EMPLOYEES e WHERE FIRST_NAME LIKE 'S%';

SELECT * FROM EMPLOYEES e WHERE FIRST_NAME LIKE '%e%';

SELECT FIRST_NAME, COMMISSION_PCT FROM EMPLOYEES e
WHERE COMMISSION_PCT IS NOT NULL;

-- employees 테이블에서 
-- salary가 4000을 초과하면서(AND), 
-- job_id가 IT_PROG인 값을 조회하세요.
SELECT * FROM EMPLOYEES e
WHERE SALARY > 4000 AND JOB_ID = 'IT_PROG';

-- NOT
SELECT * FROM EMPLOYEES e WHERE EMPLOYEE_ID <> 100;

SELECT * FROM EMPLOYEES e
WHERE EMPLOYEE_ID NOT BETWEEN 110 AND 115;

SELECT * FROM EMPLOYEES e
WHERE EMPLOYEE_ID NOT IN (110, 115, 117);

-- 함수 : SELECT, WHERE, ORDER BY / HAVING (그룹 함수)

SELECT lower('ABCD') FROM dual;

SELECT UPPER('abcd') FROM dual;

SELECT INITCAP('abcd') FROM dual;

SELECT SUBSTR('abc', 1, 1) FROM dual; -- SQL에서는 첫번째 인덱스가 1이다.

-- 문자 바꾸기
SELECT REPLACE ('abcd', 'a', 'e') FROM dual; -- (dual은 테스트로 사용하는 가상 테이블)

-- 문자 더하기
SELECT CONCAT('a', 'b') FROM dual; 

-- 문자 길이 구하기
SELECT LENGTH ('asdf') FROM dual;

-- 문자 채우기
SELECT LPAD('a', '5', '*') FROM dual;
SELECT RPAD('a', '5', '*') FROM dual;

-- 숫자 함수
SELECT ROUND(12.321, 0) FROM dual;

SELECT TRUNC(12.521, 0) FROM dual;

SELECT MOD(11, 5) FROM dual;

SELECT CEIL (12.4) FROM dual;

SELECT POWER(2, 3) FROM dual;

SELECT SQRT(4) FROM dual;

SELECT sign(12345) FROM dual; -- 양수 음수 0 확인

-- 날짜
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES e WHERE HIRE_DATE < '2003-01-01';

-- 날짜 더하기
SELECT FIRST_NAME, HIRE_DATE, HIRE_DATE +1 FROM EMPLOYEES e;

-- 날짜 간격 구하기
SELECT FIRST_NAME, HIRE_DATE, HIRE_DATE - TO_DATE('2000-01-01') FROM EMPLOYEES e;

-- 시간 더하기
SELECT FIRST_NAME, HIRE_DATE, HIRE_DATE + 1 / 24 / 60 / 60 FROM EMPLOYEES e;

-- 컴퓨터 날짜 구하기
SELECT SYSDATE FROM dual;

-- 개월수 계산
SELECT MONTHS_BETWEEN(SYSDATE, HIRE_DATE) FROM EMPLOYEES e;

-- 달 추가
SELECT HIRE_DATE, ADD_MONTHS(HIRE_DATE, 6) FROM EMPLOYEES e;

-- 마지막 날
SELECT HIRE_DATE, LAST_DAY(HIRE_DATE) FROM EMPLOYEES e;

-- 다음 요일 날짜
SELECT NEXT_DAY(SYSDATE, 1) FROM dual;

-- 날짜 반올림 절삭
SELECT HIRE_DATE, ROUND(HIRE_DATE,'MONTH') FROM EMPLOYEES e
WHERE EMPLOYEE_ID BETWEEN 100 AND 106;
-- ROUND(HIRE_DATE,'YEAR'), TRUNC(HIRE_DATE,'MONTH'), TRUNC(HIRE_DATE,'YEAR')

-- 날짜 -> 문자
SELECT TO_CHAR(SYSDATE, 'yyyy/mm/dd') FROM dual;

-- 문자 -> 숫자
SELECT 1 + TO_NUMBER('3') FROM dual;

-- 시간
SELECT TO_CHAR(SYSDATE, 'hh-mi-ss pm') FROM dual;

-- null 처리 함수
SELECT EMPLOYEE_ID, NVL(COMMISSION_PCT, 0) FROM EMPLOYEES e;

-- 조건 처리 (if와 비슷)
SELECT DECODE(COMMISSION_PCT, NULL, 0, COMMISSION_PCT) FROM EMPLOYEES e; -- DECODE는 동등 조건만 처리 가능

-- 조건 처리 (case)
SELECT CASE WHEN COMMISSION_PCT IS NULL THEN 0 WHEN COMMISSION_PCT < 0.2
THEN 1 ELSE COMMISSION_PCT END AS C_PCT FROM EMPLOYEES e;

-- 순위 매기기 (점수가 같을 때 2위가 2명이면 다음 순위를 3위 or 4위)
SELECT FIRST_NAME, SALARY, RANK () OVER (ORDER BY SALARY DESC) FROM EMPLOYEES e;
SELECT FIRST_NAME, SALARY, DENSE_RANK () OVER (ORDER BY SALARY DESC) FROM EMPLOYEES e;

-- 순위 같아도 숫자 넘김
SELECT FIRST_NAME, SALARY, ROW_NUMBER () OVER (ORDER BY SALARY DESC) FROM EMPLOYEES e;

-- 그룹 함수 (숫자 세기)
SELECT count(DEPARTMENT_ID) FROM EMPLOYEES e
GROUP BY DEPARTMENT_ID;

-- 월급이 5000 달러 이상인 사람 숫자 구하기
SELECT COUNT(*)  FROM EMPLOYEES e WHERE SALARY >= 5000;

-- 회사 월급 평균 구하기
SELECT FLOOR(AVG(SALARY)) FROM EMPLOYEES e;

SELECT JOB_ID, SUM(SALARY) 총급여, AVG(SALARY) AS "평균 급여" FROM EMPLOYEES e WHERE EMPLOYEE_ID >= 10 GROUP BY JOB_ID
HAVING SUM(SALARY) >= 30000  ORDER BY 총급여 DESC;

-- 조인 (카티션 곱 : 정확한 조인은 아님.)
SELECT * FROM EMPLOYEES e, DEPARTMENTS d
WHERE e.DEPARTMENT_ID = d.DEPARTMENT_ID;

-- 오라클 inner join
SELECT e.FIRST_NAME, d.DEPARTMENT_NAME
FROM EMPLOYEES e, DEPARTMENTS d
WHERE e.DEPARTMENT_ID = d.DEPARTMENT_ID;

-- ansi inner join
SELECT e.FIRST_NAME, d.DEPARTMENT_NAME
FROM EMPLOYEES e INNER JOIN DEPARTMENTS d
ON e.DEPARTMENT_ID = d.DEPARTMENT_ID;

-- 오라클 outer join
SELECT e.FIRST_NAME, d.DEPARTMENT_NAME
FROM EMPLOYEES e, DEPARTMENTS d
WHERE e.DEPARTMENT_ID = d.DEPARTMENT_ID(+);

-- ansi outer join
SELECT e.FIRST_NAME, d.DEPARTMENT_NAME
FROM EMPLOYEES e LEFT OUTER JOIN DEPARTMENTS d
ON e.DEPARTMENT_ID = d.DEPARTMENT_ID;

-- self join
SELECT emp.FIRST_NAME 직원, ma.FIRST_NAME 매니저 FROM EMPLOYEES emp INNER JOIN EMPLOYEES ma
ON emp.MANAGER_ID = ma.EMPLOYEE_ID;

-- 서브쿼리
-- SELECT 서브쿼리 = 스칼라 서브쿼리
-- FROM 서브쿼리 = 인라인뷰 서브쿼리
-- WHERE 서브쿼리 = 서브쿼리
-- employees 테이블의 last_name이 
--‘De Haan’인 직원과 salary가 동일한 직원에는 
-- 누가 있는지 단일 행 서브쿼리를 이용해서 출력해 보세요

-- 서브쿼리를 이용한 쿼리를 작성할 때에는 서브쿼리부터 먼저 작성하기!
-- 단일행 서브쿼리
SELECT SALARY FROM EMPLOYEES e2 WHERE LAST_NAME = 'De Haan';
SELECT LAST_NAME, SALARY FROM EMPLOYEES e WHERE SALARY =
(SELECT SALARY FROM EMPLOYEES e2 WHERE LAST_NAME = 'De Haan');

-- 다중행 서브쿼리 (행 개수가 여러개 -> in절)
-- employees 테이블에서 department_id별로 
-- 가장 낮은 salary가 얼마인지 찾아보고, 
-- 찾아낸 salary에 해당하는 직원이 누구인지 
-- 다중 행 서브쿼리를 이용해 찾아보세요.
SELECT MIN(SALARY) FROM EMPLOYEES GROUP BY DEPARTMENT_ID;
SELECT FIRST_NAME, SALARY FROM EMPLOYEES 
WHERE SALARY IN (SELECT MIN(SALARY) FROM EMPLOYEES GROUP BY DEPARTMENT_ID);

-- 인라인뷰 서브쿼리
-- 직원 중에서 department_name이
-- IT인 직원의 정보를
-- 인라인 뷰를 이용해 출력해 보세요.
SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = 'IT';
SELECT * FROM EMPLOYEES e
INNER JOIN (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = 'IT') d
ON e.DEPARTMENT_ID = d.DEPARTMENT_ID;

SELECT * FROM EMPLOYEES WHERE SALARY > 10000;

SELECT * FROM (SELECT * FROM EMPLOYEES WHERE SALARY > 10000);

-- 스칼라 서브쿼리
SELECT FIRST_NAME, 
(SELECT DEPARTMENT_NAME
FROM DEPARTMENTS d
WHERE e.DEPARTMENT_ID = d.DEPARTMENT_ID)
FROM EMPLOYEES e;

-- INSERT UPDATE DELETE
-- create alter
-- grant

-- ddl dml 차이
-- 트랜잭션 commit rollback
-- 제약조건
